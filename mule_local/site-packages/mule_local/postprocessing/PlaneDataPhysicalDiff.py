#! /usr/bin/env python3

import sys
import math

import numpy as np
from scipy.interpolate import RectBivariateSpline

from mule_local.postprocessing.PlaneDataPhysical import *
from mule.InfoError import *



class PlaneDataPhysicalDiff(InfoError):

	def __init__(
		self,
		filename_reference = None,
		filename_b = None,
		params = ['interpolate']
	):
		"""
		Parameters:

		filname_reference: string
			Filename (full path) of reference data

		filename_b: string
			Filename (fullpath) of data to compare with


		params: list of strings

			'default':
				only support 1:1 resolution matching

			'ref_reduce':
				if resolutions don't match, reduce reference solution to lower resolution if higher resolution is integer scaling factor larger

			'interpolate':
				if resolutions don't match, interpolate to reference resolution (cubic interpolation)
		"""

		InfoError.__init__(self, "PlaneDataPhysicalDiff")
		self.params = params

		if filename_b != None:
			self.compute_diff(filename_reference, filename_b, params)

		pass



	def compute_diff(
			self,
			filename_a,
			filename_b,
			params,
		):

		# Load first file_b, to avoid wasting time for filename_a if filename_b doesn't exist
		file_b = PlaneDataPhysical(filename_b)
		file_a = PlaneDataPhysical(filename_a)


		self.norm_l1_value = 0.0
		self.norm_l2_value = 0.0
		self.norm_linf_value = 0.0
		self.norm_rms_value = 0.0
		self.N = 0

		size_ref_j = len(file_a.data)
		size_ref_i = len(file_a.data[0])
		size_cmp_j = len(file_b.data)
		size_cmp_i = len(file_b.data[0])

		if size_ref_j == size_cmp_j and size_ref_i == size_cmp_i and False:
			self.info("Using 'default' method (matching resolutions)")

			#
			# Grids have same resolution
			#
			for j in range(0, size_cmp_j):
				for i in range(0, size_cmp_i):
					value = file_b.data[j,i]-file_a.data[j,i]

					# http://mathworld.wolfram.com/L1-Norm.html
					self.norm_l1_value += abs(value)

					# http://mathworld.wolfram.com/L2-Norm.html
					self.norm_l2_value += value*value

					# http://mathworld.wolfram.com/L-Infinity-Norm.html
					self.norm_linf_value = max(abs(value), self.norm_linf_value)

					# http://mathworld.wolfram.com/Root-Mean-Square.html
					self.norm_rms_value += value*value

					self.N += 1


		elif 'ref_reduce' in params:
			self.info("Using 'ref_reduce' method")

			#
			# Reduce reference solution, assuming that the
			# resolution is integer multiples of the one to compare with
			#

			multiplier_j = size_ref_j/size_cmp_j
			multiplier_i = size_ref_i/size_cmp_i


			print("Dimensions of reference solution: ", size_ref_i, size_ref_j)
			print("Dimensions of method under analysis: ", size_cmp_i, size_cmp_j)

			if not float(multiplier_i).is_integer() or not float(multiplier_j).is_integer() : 
				print("Grids are not aligned")
				print("Try to use (TODO) interpolation script")
				print("Dimensions of method under analysis: ", size_cmp_i, size_cmp_j)
				print("Multipliers: ", multiplier_i, multiplier_j)
				raise Exception("Grids not properly aligned")

			multiplier_j = int(multiplier_j)
			multiplier_i = int(multiplier_i)

			if multiplier_j != 1 or multiplier_i != 1:
				info("WARNING: With multiplilers != 1, this only works for DoFs which are stored starting at (0,0) and not for DoFs staggered relative to (0,0)!")

			print("Using multipliers (int): ", multiplier_i, multiplier_j)

			for j in range(0, size_cmp_j):
				for i in range(0, size_cmp_i):
					value = file_b.data[j,i]-file_a.data[j*multiplier_j,i*multiplier_i]

					# http://mathworld.wolfram.com/L1-Norm.html
					self.norm_l1_value += abs(value)

					# http://mathworld.wolfram.com/L2-Norm.html
					self.norm_l2_value += value*value

					# http://mathworld.wolfram.com/L-Infinity-Norm.html
					self.norm_linf_value = max(abs(value), self.norm_linf_value)

					# http://mathworld.wolfram.com/Root-Mean-Square.html
					self.norm_rms_value += value*value

					self.N += 1


		elif 'interpolate' in params:
			self.info("Using interpolation method")

			#
			# Interpolate solution to resolution of reference solution.
			# Note, that this can also lead to a reduction in case of a lower resolution of the reference
			#

			# This is the code written by Pedro which uses spline interpolation

			# Comparison via interpolation
			# print("Interpolation")
			# A-grid REFERENCE (file1) - sweet outputs only A grids physical space

			data_ref = file_a.data
			data_cmp = file_b.data

			ny_ref = len(file_a.data)
			nx_ref = len(file_a.data[0])
			print("REF resolution: "+str(nx_ref)+", "+str(ny_ref))

			ny_cmp = len(file_b.data)
			nx_cmp = len(file_b.data[0])
			print("CMP resolution: "+str(nx_cmp)+", "+str(ny_cmp))

			dx_ref = 1.0/(nx_ref)
			dy_ref = 1.0/(ny_ref)
			x_ref = np.linspace(0, 1, nx_ref)
			y_ref = np.linspace(0, 1, ny_ref)
			x_ref += dx_ref/2	# Make it cell-centered
			y_ref += dy_ref/2
			X_ref, Y_ref = np.meshgrid(x_ref, y_ref)

			# Create cubic interpolation of reference file
			interp_spline = RectBivariateSpline(x_ref, y_ref, data_ref)

			# A-grid cmp file (file2)
			dx_cmp=1.0/nx_cmp
			dy_cmp=1.0/ny_cmp
			x_cmp = np.linspace(0, 1, nx_cmp)
			y_cmp = np.linspace(0, 1, ny_cmp)
			x_cmp += dx_cmp/2
			y_cmp += dy_cmp/2
			X_cmp, Y_cmp = np.meshgrid(x_cmp, y_cmp)

			# Compute reduced reference resolution
			data_ref_low = interp_spline(x_cmp, y_cmp)

			#
			# Grids have same resolution
			#
			for j in range(0, ny_cmp):
				for i in range(0, nx_cmp):
					value = data_cmp[j,i] - data_ref_low[j,i]

					# http://mathworld.wolfram.com/L1-Norm.html
					self.norm_l1_value += abs(value)

					# http://mathworld.wolfram.com/L2-Norm.html
					self.norm_l2_value += value*value

					# http://mathworld.wolfram.com/L-Infinity-Norm.html
					self.norm_linf_value = max(abs(value), self.norm_linf_value)

					# http://mathworld.wolfram.com/Root-Mean-Square.html
					self.norm_rms_value += value*value

					self.N += 1

		else:
			print("")
			print("No supported method provided in '"+(','.join(params))+"'")
			print("")
			raise Exception("No supported method provided in '"+(','.join(params))+"'")


		# Compute sqrt() for Euklidian L2 norm
		self.norm_l2_value = math.sqrt(self.norm_l2_value)

		# RMS final sqrt(N) computation
		self.norm_rms_value  = math.sqrt(self.norm_rms_value/float(self.N))

		# resolution normalized L1 value
		self.res_norm_l1_value = self.norm_l1_value/float(self.N)




	def print(self):
		print("")
		print(" + norm l1: "+str(self.norm_l1_value))
		print(" + norm l2: "+str(self.norm_l2_value))
		print(" + norm linf: "+str(self.norm_linf_value))
		print(" + norm rms: "+str(self.norm_rms_value))
		print(" + res norm l1: "+str(self.res_norm_l1_value))
		print("")



	def write_file(
			self,
			picklefile,
			tagname = None
		):

		#
		# If picklefile is specified, write norm data to pickle file.
		# This can be later on further postprocessed!
		#
		if picklefile != None:
			import pickle

			if tagname != None:
				tagname += '.'
			else:
				tagname = ''

			pickle_data = {
				tagname+'N' : self.N,
				tagname+'norm_l1' : self.norm_l1_value,
				tagname+'norm_l2' : self.norm_l2_value,
				tagname+'norm_linf' : self.norm_linf_value,
				tagname+'norm_rms' : self.norm_rms_value,
			}

			# Write values for resolution neutral values into the .pickle files
			pickle_data.update({
				tagname+'res_norm_l1' : self.res_norm_l1_value,
				tagname+'res_norm_l2' : self.norm_rms_value,	# This is the RMS = L2
				tagname+'res_norm_linf' : self.norm_linf_value,	# No normalization required
				tagname+'res_norm_rms' : self.norm_rms_value,	# Already normalized
			})

			print(" + picklefile: "+str(picklefile))

			with open(picklefile, 'wb') as f:
				# Pickle the 'data' dictionary using the highest protocol available.
				pickle.dump(pickle_data, f)

		print("")



if __name__ == "__main__":
	if len(sys.argv) < 3:
		print("")
		print("Usage:")
		print("	"+sys.argv[0]+" [infile A] [infile B] [parameters] [picklefile output file (optional)] [reference tagname (optional)]")
		print("")
		print("	infile A:")
		print("		First input .csv file with physical space data on the plane")
		print("")
		print("	infile B:")
		print("		Second input .csv file with physical space data on the plane")
		print("")
		print("	parameters:")
		print("		'interpolate':")
		print("			use interpolation if resolutions don't match")
		print("")
		print("	picklefile:")
		print("		If given, output is pickled into this file")
		print("		diff.error_l1")
		print("		diff.error_l2")
		print("		diff.error_linf")
		print("		diff.error_rms")
		print("")
		print(" reference tagname:")
		print("		How to name value in .pickle file")
		print("")
		sys.exit(1)



	filename_a = sys.argv[1]
	filename_b = sys.argv[2]

	params = []
	if len(sys.argv) > 3:
		params = sys.argv[3].split(' ')

	picklefile = None
	if len(sys.argv) > 4:
		picklefile = sys.argv[4]

	tagname = None
	if len(sys.argv) > 5:
		tagname = sys.argv[5]

	print("")
	print("parameters: "+str(params))
	print("picklefile: "+str(picklefile))
	print("tagname: "+str(tagname))
	print("")

	s = PlaneDataPhysicalDiff()
	s.compute_diff(filename_a, filename_b, params)
	s.print()

	if picklefile != None:
		s.write_file(picklefile, tagname)
