#! /usr/bin/env python3

#
# Author: Martin Schreiber
# Email: schreiberx@gmail.com
# Date: 2017-06-18
#

import sys
import math
import mule_local.rexi.EFloat as ef



#
# Supported Functions to approximate
#
class Functions:

	def phiN(
		self,
		n: int,
		z
	):
		"""
		Recursive calculation of phiN functions.

		This formulation has the big advantage, that the numerical errors for
		$$
			z \approx a
		$$
		can be treated in a 
		"""
		if n == 0:
			return self.efloat.exp(z)

		if abs(self.efloat.abs(z) < self.epsthreshold):
			return self.efloat.to(1.0)/self.efloat.to(math.factorial(n))

		return (self.phiN(n-1, z) - self.efloat.to(1.0)/self.efloat.to(math.factorial(n-1)))/z;



	def __init__(
		self,
		function_name = "phi0",
		efloat_mode = None
	):
		self.efloat = ef.EFloat(efloat_mode)

		self.function_name = function_name

		self.function_complex = True

		if self.efloat.floatmode == 'mpfloat':
			import mpmath as mp
			# Set numerical threshold to half of precision
			self.epsthreshold = 1e-10
		else:
			self.epsthreshold = 1e-10


		# Exponential integrator: phi0
		if self.function_name[0:3] == 'phi':

			N = int(self.function_name[3:])

			def fun(x):
				return self.phiN(N, x)

			self.eval = fun

			if self.function_complex:
				self.is_real_symmetric = True
				self.is_complex_conjugate_symmetric = True
			else:
				self.is_real_symmetric = True
				self.is_complex_conjugate_symmetric = False

		elif self.function_name[0:3] == 'ups':

			N = int(self.function_name[3:])

			if self.efloat.floatmode == 'mpfloat':
				import mpmath as mp
				# Set numerical threshold to half of precision
				self.epsthreshold = 1e-10
			else:
				self.epsthreshold = 1e-10

			if N == 1:

				#
				# Setup \upsilon_1 for EDTRK4
				# See document notes_on_time_splitting_methods.lyx
				#
				def fun(x):
					K = x
					if abs(x) < self.epsthreshold:
						return self.efloat.to(1.0)/self.efloat.to(2.0*3.0)
					else:
						return (-self.efloat.to(4.0)-K+self.efloat.exp(K)*(self.efloat.to(4.0)-self.efloat.to(3.0)*K+K*K))/(K*K*K)
				self.eval = fun

				if self.function_complex:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = True
				else:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = False


			elif N == 2:
				#
				# Setup \upsilon_2 for EDTRK4
				# See document notes_on_time_splitting_methods.lyx
				#
				def fun(x):
					K = x
					if abs(x) < self.epsthreshold:
						return self.efloat.to(1.0)/self.efloat.to(2.0*3.0)
					else:
						return (self.efloat.to(2.0)+1.0*K+self.efloat.exp(K)*(self.efloat.to(-2.0)+K))/(K*K*K)
				self.eval = fun

				if self.function_complex:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = True
				else:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = False


			elif N == 3:
				#
				# Setup \upsilon_3 for EDTRK4
				# See document notes_on_time_splitting_methods.lyx
				#
				def fun(x):
					K = x
					if abs(x) < self.epsthreshold:
						return self.efloat.to(1.0)/self.efloat.to(2.0*3.0)
					else:
						return (-self.efloat.to(4.0) - 3.0*K - K*K + self.efloat.exp(K)*(self.efloat.to(4.0)-K))/(K*K*K)
				self.eval = fun

				if self.function_complex:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = True
				else:
					self.is_real_symmetric = True
					self.is_complex_conjugate_symmetric = False

			else:
				print("Unknown ups function "+str(N))
				sys.exit(1)

		else:
			print("Unknown basis function "+str(self.function_name))
			sys.exit(1)


