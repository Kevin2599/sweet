#! /usr/bin/env python3

import numpy as np

from Functions import *
from trexi.TREXI import *
from cirexi.CIREXI import *
from butcherrexi.ButcherREXI import *


for rexi_method in [
		"trexi",
		"cirexi",
		"butcherrexi_gauss",
		"butcherrexi_radau",
		"butcherrexi_chebyshev",
	]:

	for function_name in ["phi0", "phi1", "phi2", "phi3", "ups1", "ups2", "ups3"]:
	#for function_name in ["phi0"]:

		# T-REXI: Number of Gaussian basis functions
		M = 256

		# T-REXI: Spacing between Gaussian basis functions
		h = 0.2


		# CI-REXI: Number of quadrature poles
		#N = M
		N = 256

		# CI-REXI: Radius
		#R = M*h

		# CI-REXI: Value on imaginary axis to be included
		lambda_include_imag = 20

		# CI-REXI: Maximum value of quadrature pole
		lambda_max_real = 10


		# Butcher-REXI
		butcherOrder = 10


		# Testing: number of samples
		num_test_samples = 1234

		# Testing: Range (start, end)
		test_range = [None, None]

		# Error to test for
		error_eps = 1e-9

		# verbose
		verbosity = 10
		verbosity = 0

		# efloat_mode
		efloat_mode = "float"
		#efloat_mode = "mpfloat"


		coeffs = None

		if rexi_method == "trexi":

			if function_name != "phi0":
				continue

			trexi = TREXI(efloat_mode=efloat_mode)
			coeffs = trexi.setup(
				function_name = function_name,
				M = N,
				h = h
			)

			# Convert to floating point
			coeffs = coeffs.toFloat()
			unique_id_string = trexi.getUniqueId()

			test_range = [-N*h*0.95, N*h*0.95]


		elif rexi_method == "cirexi":

			cirexi = CIREXI(efloat_mode=efloat_mode)

			coeffs = cirexi.setup(
				function_name = function_name,
				N = N,
				lambda_max_real = lambda_max_real,
				lambda_include_imag = lambda_include_imag
			)

			# Convert to floating point
			coeffs = coeffs.toFloat()

			unique_id_string = cirexi.getUniqueId()

			test_range = [-lambda_include_imag*0.8, lambda_include_imag*0.8]



		elif rexi_method == "butcherrexi_gauss":

			if function_name != "phi0":
				continue

			butcherrexi = ButcherREXI(efloat_mode=efloat_mode)
			coeffs = butcherrexi.setup(N=butcherOrder, quadrature_method="gauss")

			# Convert to floating point
			coeffs = coeffs.toFloat()
			unique_id_string = butcherrexi.getUniqueId()
			test_range = [butcherOrder*0.5, butcherOrder*0.5]


		elif rexi_method == "butcherrexi_radau":

			if function_name != "phi0":
				continue

			butcherrexi = ButcherREXI(efloat_mode=efloat_mode)
			coeffs = butcherrexi.setup(N=butcherOrder, quadrature_method="radau")

			# Convert to floating point
			coeffs = coeffs.toFloat()
			unique_id_string = butcherrexi.getUniqueId()
			test_range = [butcherOrder*0.5, butcherOrder*0.5]

		elif rexi_method == "butcherrexi_chebyshev":

			if function_name != "phi0":
				continue

			butcherrexi = ButcherREXI(efloat_mode=efloat_mode)
			coeffs = butcherrexi.setup(N=butcherOrder, quadrature_method="chebyshev")

			# Convert to floating point
			coeffs = coeffs.toFloat()
			unique_id_string = butcherrexi.getUniqueId()
			test_range = [butcherOrder*0.25, butcherOrder*0.25]


		else:
			raise Exception("Unsupported REXI method")

		function = Functions(
			function_name = function_name,
			efloat_mode = "float"
		)


		print("")
		print(unique_id_string)
		print(" + function_name: "+function_name)

		max_error = 0
		for x in np.linspace(test_range[0], test_range[1], num_test_samples):
			lam = 1j*x

			y = function.eval(lam)
			yn = coeffs.eval(lam)

			err = np.abs(y-yn)

			if verbosity > 0:

				#if True:
				if False:
					print("x="+str(lam)+"\t\terror="+str(err))
				else:
					print("Lambda: "+str(lam))
					print(" +  exact: "+str(y))
					print(" + approx: "+str(yn))
					print(" + Error: "+str(err))
					print("")

			max_error = max(max_error, err)


		if verbosity == 0:
			print(" + test_range: ["+str(test_range[0])+", "+str(test_range[1])+"]")
			print(" + Error: "+str(max_error))

		if max_error > error_eps:
			raise Exception("Error threshold "+str(error_eps)+" exceeded")

		coeffs.write("/tmp/REXI_"+rexi_method+"_"+unique_id_string+".txt")

